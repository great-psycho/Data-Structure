# Hash
- 데이터를 효율적으로 관리하기 위해 임의의 길이 데이터를 고정된 길이의 데이터로 매핑 하는 것.
- 매핑 전 원래 데이터 값을 키(key)
- 매핑 후 데이터 값을 해시값(hash value)
- 매핑 하는 과정을 해싱(hashing)이라고 한다.

## 해시테이블 
- 해시함수를 사용하여 키를 해시값으로 매핑하고,    
이 해시값을 색인(index) or 주소로 삼아 데이터 값(value)을 키와 함께 저장하는 구조를 의미 
- 이때 데이터가 저장되는 곳은 버킷(buket) or 슬롯(slot)이라 한다. 

### 해시테이블의 장점
- 무한에 가까운 데이터(키)들을 유한한 개수의 해시값으로 매핑하여 작은 크기의 메모리로도 프로세스를 관리할 수 있다.
- 해시 함수는 언제나 동일한 해시값을 리턴한다.
- 해시는 데이터 액세스(삽입, 삭제, 탐색)시 계산복잡성을 𝑂(1)을 지향한다.
- 보안에서는 키와 해시값 사이에 직접적인 연관이 없어 해시값만으로 키를 복원하기 어렵다.

### Direct-address-table 
- 키의 전체 개수와 동일한 크기의 버킷을 가진 해시테이블 
- 특징
  - 해시충돌 문제가 발생하지 않는다.
  - 전체 키가 실제 사용하는 키보다 훨씬 많은 경우 사용하지 않는 키들의 공간까지 필요해 메모리 효율성이 떨어진다.

### loadFactor
- loadFactor = 해시 테이블 크기 (m) / 실제 사용하는 키 개수(n)
- 해시테이블의 한 버킷에 평균 몇개의 키가 매핑 되는가를 나타내는 지표
- Direct-address-table 의 loadFactor 는 1이하로, 1보다 큰 경우 해시충돌이 일어난다.

## 해시 충돌(collision)
- 해시 함수는 해쉬값의 개수보다 대개 많은 키값을 해쉬값으로 변환(many-to-one 대응)하기 때문에   
  해시함수가 서로 다른 두개의 키에 대해 동일한 해시값을 내는 해시 충돌(collision)이 발생하게 된다.

## 해시충톨 해결 방법

### 1. chaining 
- 한 버킷당 들어갈 수 있는 엔트리의 수에 제한을 두지 않는 방법으로 모든 자료를 해시 테이블에 담는 것이다.
- 해당 버킷에 데이터가 이미 있으면 체인처럼 노드를 추가하여 다음 노드를 가리키는 방식 (연결 리스트)
- 유연한 장점이 있으나 메모리 문제를 야기할 수 있다. 
- 두개의 데이터가 같은 해시값으로 매핑되면 최근 데이터를 head로 하여 두개의 데이터를 저장한다.
#### 계산 복잡성
- 삽입의 계산 복잡성
  - 새로운 키를 해시값 200으로 매핑시 해당 해시값으로 매핑 O(1)
  - 해당 해시값의 연결리스트(head)에 추가 O(1)이 든다.
  - 총 O(1)
- 탐색의 계산 복잡성
  - 가정 1. 없는 데이터를 탐색
    - 키를 해시값으로 바꾸고 해당 해시값에 해당하는 버킷의 요소들(x개)을 전부 탐색
    - 총 O(1+x)
  - 가정 2. 해당 데이터가 있는경우 탐색
    - Big O notation의 계산 복잡성은 최악의 경우를 고려해야한다. 
    - tail에 값이 있는 경우 해당하는 버킷의 x개의 요소 중 x-1개를 비교한 다음일 것이다.
    - 그러므로, 총 O(1+x)으로 데이터가 없을 때와 동일하다.
- 삭제의 계산 복잡성
  - 해당 데이터가 있는지 확인부터 해야하기 때문에 탐색과 비슷하다.
  - 키값을 해시값으로 매핑(O(1)) + 해당하는 버킷의 x개의 요소 탐색 (O(x)) + 삭제(O(1))-무시할만한 수준
  - 총 O(1+x)
  - 데이터의 개수가 해시테이블 크기의 두 세배만 되어도 탐색,삭제는 O(1)이 된다.

### 2. open addressing
- 버킷당 들어갈 수 있는 엔트리가 하나뿐인 해시테이블
- 해시함수로 얻은 주소가 아닌, 다른 주소에 데이터를 저장 할 수 있도록 허용
- 해시충돌이 발생할 수 있다.
#### 속성
- 이미 데이터가 들어있는 버킷의 해시값과 겹치면 다른 빈 해시값의 버킷으로 데이터가 들어가게 된다.

#### probing(탐사)
- 특정 해시값에 키가 몰리게 되면 발생하는 해시충돌을 방지하기 위해 삽입,삭제,탐색 시 새로운 주소를 찾는 과정
- 선형 탐사
    - 해당 해시값에 데이터가 있으면 바로 다음 해시값에 데이터를 넣어준다.
    - 주변 값이 모두 채워져 있는 경우 취약하다.(여러번 탐사 필요)
- 제곱 탐사
    - 충돌시 다음 해시값을 제곱수로 늘어나는 차이로 지정해주는 방식
    - 초기 해시값이 같으면 탐사 위치도 동일하여 여러번 탐사하게 된다.
- 이중해싱
    - 해시값의 규칙성을 없엔 방식
        - 해시 함수를 2개 만들어 하나는 최초 해시값을 얻기, 나머지 하나는 해시충돌시 탐사 이동폭을 설정
      
#### 삭제, 삽입, 탐색 (선형 탐사)
1. 삽입   
      <img width="500" alt="해시 삽입" src="https://user-images.githubusercontent.com/90807141/200140814-5603889c-27de-4489-ab74-a0c6bfa87333.png">

     - 3 해시값에 A,B,C 데이터가 순차적으로 들어간다.
     - A는 3해시값에 들어가고, B는 3에 데이터가 있어 다음(4)에 들어가게되고, C는 B의 다음(5) 에 들어가게 된다.

2. 삭제 & 탐색  
      <img width="500" alt="해시 삭제" src="https://user-images.githubusercontent.com/90807141/200140819-ab3536bc-9623-4d88-b187-55e8a96c79fc.png">

     - B 삭제 : 3 해시값으로 탐색 A 데이터가 있어 다음 해시값(4)을 탐색 B 삭제
     - C 탐색 : 3 해시값으로 탐색 A 데이터가 있어 다음 해시값(4)을 탐색 데이터가 없어서 탐색을 마친다.  
          B 삭제를 하고 빈값으로 해시를 냅두고 C 데이터를 탐색하면 데이터를 찾지 못하고 종료하는 상황이 나올수 있다.  
          이를 위해 삭제 후에 del 같은 별도 표시를 해준다.  
      <img width="500" alt="해시 삽입 3" src="https://user-images.githubusercontent.com/90807141/200140826-44197a7a-902f-4762-9392-d326af3665b1.png">

#### 계산 복잡성
- chaining과 달리 해시테이블의 크기(m)가 고정돼 있으므로 n개 데이터를 모두 저장하려는 경우 Load Factor a=n/m는 1과 같거나 작다고 가정.    
          (open addressing은 해시테이블에 데이터가 꽉 차지 않는다는 걸 전제로 한다.)
- open addressing에 적용된 해시함수는 키들을 모든 버킷에 균등하게 할당한다고 가정하고 계산복잡성을 분석한다.
- 탐색의 계산 복잡성은 탐사(probing) 횟수에 비례하다.

### 3. 해시함수
- 해시테이블의 크기가 m이라면, 좋은 해시함수는 임의의 키값을 임의의 해시값에 매핑할 확률이 1/m이 될 것이다.
- 즉, 특정 값에 치우치지 않고 해시값을 고르게 만들어내는 해시함수가 좋은 해시함수이다.

#### division method
- 숫자로 된 키를 해시테이블 크기 m으로 나눈 나머지를 해시값으로 반환

#### multiplication method
- 숫자로 된 키가 k이고 A는 0과 1 사이의 실수일 때 곱셈법은 다음과 같이 정의된다.  
  h(k) = (kA mod 1) x m
- m이 얼마가 되든 크게 중요하지는 않으며 보통 2의 제곱수로 정한다.

#### universal hasing
- 다수의 해시함수를 만들고, 이 해시함수의 집합 H에서 무작위로 해시함수를 선택해 해시값을 만드는 기법

<br>

참고 블로그  [ratsgo's blog](https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/) 