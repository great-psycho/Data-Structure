# Array 배열

배열은 메모리 공간을 예약/할당하기 위해 길이를 미리 알려줘야만 한다.

```java
int[] arr = new int[5];
```

## Read O(1)

```java
int num = arr[0];
```

배열에 담긴 값을 읽고 싶다면 인덱스로 그 위치에 있는 값을 읽어올 수 있다.

따라서, 배열 안에 있는 값을 읽어오는 것은 매우 빠르다.

## Search

### Linear Search 선형 검색 O(N)

```java
int arr[] = {?, ?, ?, ?, ?};

int num = 1;
int index = -1;

for (int i = 0; i < arr.length; i++) {
		if (arr[i] == num) {
				index = i;
				break;
		}
}
```

배열은 특정 값이 있는지 없는지 모른다. 따라서, 검색하기 위해서는 배열에 담긴 값을 하나하나 꺼내서 확인해야 한다.

최악의 경우 찾는 값이 없거나 마지막 위치에 있다면, 모든 값을 열어봐야될 것 이다.

## Insert

+ 메모리 공간이 있는 경우
  + 가장 마지막 위치에 추가하는 경우 : 바로 값을 넣으면 됨. 빠름
  + 중간에 추가하는 경우 : 오른쪽에 있는 값들을 하나씩 밀고 추가해야함.
  + 맨 앞자리에 넣는 경우 : 모든 값을 하나씩 밀고 추가해야함.
+ 메모리 공간이 없는 경우
  + 더 큰 배열을 만들어서, 기존 배열을 복사하고 추가해야함.
  + 요소를 복사하고 추가하는 등 시간이 오래 걸림.

## Delete
+ 마지막 요소를 제거할 경우 : 바로 삭제하면 됨.
+ 배열 중간 요소를 삭제할 경우 : 삭제 후 공백을 메우기 위해 뒤에 있는 요소들을 하나씩 땡겨 옮겨줘야함.
+ 가장 앞자리 요소를 제거하는 경우 : 나머지 모든 요소를 전부 옮겨야함.

## 정리

배열은 데이터를 읽을때 인덱스로 바로 접근 가능하기 때문에 매우 빠르다.

하지만 값이 있는지 없는지, 값이 어느 위치에 있는지 모르기 때문에 검색, 추가, 삭제는 느린편이다.

가능하다면 추가, 삭제는 가장 마지막 위치에서 하는 것이 빠르기 때문에 좋다.